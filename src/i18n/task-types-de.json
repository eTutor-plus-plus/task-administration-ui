{
  "taskTypes": {
    "none": {
      "title": "Kein Typ"
    },
    "binary-search": {
      "title": "Binärsuche",
      "fields": {
        "solution": "Gesuchte Zahl"
      }
    },
    "jdbc": {
      "title": "JDBC",
      "fields": {
        "solution": "Lösung"
      }
    },
    "xquery": {
      "title": "XQuery",
      "fields": {
        "solution": "Lösung",
        "sorting": "Sortierung (XPath)",
        "missingNodePenalty": "Fehlender Knoten: Punkteabzug",
        "missingNodeStrategy": "Fehlender Knoten: Strategie",
        "superfluousNodePenalty": "Überflüssiger Knoten: Punkteabzug",
        "superfluousNodeStrategy": "Überflüssiger Knoten: Strategie",
        "displacedNodePenalty": "Fehlplatzierter Knoten: Punkteabzug",
        "displacedNodeStrategy": "Fehlplatzierter Knoten: Strategie",
        "missingAttributePenalty": "Fehlendes Attribut: Punkteabzug",
        "missingAttributeStrategy": "Fehlendes Attribut: Strategie",
        "superfluousAttributePenalty": "Überflüssiges Attribut: Punkteabzug",
        "superfluousAttributeStrategy": "Überflüssiges Attribut: Strategie",
        "incorrectTextPenalty": "Falscher Text: Punkteabzug",
        "incorrectTextStrategy": "Falscher Text: Strategie",
        "incorrectAttributeValuePenalty": "Falscher Attributwert: Punkteabzug",
        "incorrectAttributeValueStrategy": "Falscher Attributwert: Strategie"
      },
      "descriptions": {
        "sorting": "Geben Sie hier den XPath-Ausdruck an, der die Sortierung der Ergebnisse überprüft, z. B. '//person'. Ein Eintrag pro Zeile."
      },
      "strategy": {
        "KO": "K.O.-Kriterium",
        "GROUP": "Einmal pro Gruppe",
        "EACH": "Einmal pro Element"
      }
    },
    "datalog": {
      "title": "Datalog",
      "fields": {
        "solution": "Lösung",
        "query": "Abfrage",
        "uncheckedTerms": "Terme",
        "missingPredicatePenalty": "Fehlendes Prädikat: Punkteabzug",
        "missingPredicateStrategy": "Fehlendes Prädikat: Strategie",
        "missingFactPenalty": "Fehlender Fakt: Punkteabzug",
        "missingFactStrategy": "Fehlender Fakt: Strategie",
        "superfluousFactPenalty": "Überflüssiger Fakt: Punkteabzug",
        "superfluousFactStrategy": "Überflüssiger Fakt: Strategie"
      },
      "descriptions": {
        "solution": "Hier können die Regeln, welche die Lösung repräsentieren, definiert werden. Hier dürfen keine Query-Deklarationen erfolgen.",
        "query": "Wenn Sie mehrere Queries bei der Beurteilung berücksichtigen wollen, dann trennen Sie diese mittels Semikolon. Z.B. hatSohn(X,Y)?;hatTochter(X,Y)?",
        "uncheckedTerms": "Um bestimmte Terme, welche in den Fakten vorkommen, von der Manipulation auszuschließen, definieren Sie diese hier erneut. Z.B. 'hatKind(peter,_).' ,um den Term 'peter' von der Manipulation auszuschließen, sofern dieser auf Position 1 des Prädikats 'hatKind' vorkommt. Bei der Überprüfung werden Terme manipuliert, um zu verhindern, dass Studierende einfach die Fakten und keine Regeln eingeben."
      },
      "strategy": {
        "KO": "K.O.-Kriterium",
        "GROUP": "Einmal pro Gruppe",
        "EACH": "Einmal pro Element"
      }
    },
    "asp": {
      "title": "Answer Set Programming",
      "fields": {
        "solution": "Lösung",
        "maxN": "Max. Integer"
      },
      "descriptions": {
        "solution": "Hier können die Regeln, welche die Lösung repräsentieren, definiert werden. Hier dürfen keine Query-Deklarationen erfolgen."
      }
    },
    "drools": {
      "title": "Drools",
      "fields": {
        "droolsSolution": "Lösung",
        "droolsClasses": "Klassen",
        "droolsObjects": "Objekte",
        "droolsErrorWeighting": "Fehlergewichtung",
        "droolsValidationClassname": "Validierungsklasse",
        "droolsAddClass": "Klasse hinzufügen",
        "droolsClassesName": "Klassen",
        "droolsIsCEP": "Ist dieser Task ein CEP Task?"
      }
    },

    "sql-ddl": {
      "title": "SQL DDL",
      "fields": {
        "sqlDDL": "SQL DDL",
        "solution": "Lösung",
        "insertStatements": "Insert Statement",
        "tablePoints": "Punkte pro Tabelle",
        "columnPoints": "Punkte pro Spalte",
        "constraintPoints": "Punkte pro Constraint",
        "primaryKeyPoints": "Punkte pro Primary Key",
        "foreignKeyPoints": "Punkte pro Foreign Key"
  }},
    "sql": {
      "title": "SQL",
      "fields": {
        "solution": "Lösung",
        "wrongOrderPenalty": "Falsche Sortierung: Punkteabzug",
        "superfluousColumnsPenalty": "Überflüssige Spalte: Punkteabzug"
      },
      "descriptions": {
        "penalty": "Ein Punkteabzug von -1 bedeutet, dass die Abgabe mit 0 Punkten bewertet wird."
      }
    },
    "relalg": {
      "title": "Relationale Algebra",
      "fields": {
        "solution": "Lösung",
        "sqlSolution": "SQL-Lösung",
        "wrongOrderPenalty": "Falsche Sortierung: Punkteabzug",
        "superfluousColumnsPenalty": "Überflüssige Spalte: Punkteabzug"
      },
      "descriptions": {
        "penalty": "Ein Punkteabzug von -1 bedeutet, dass die Abgabe mit 0 Punkten bewertet wird."
      }
    },
    "fanf": {
      "title": "Funktionale Abhängigkeiten",
      "fields": {
        "baseRelationName": "Name der Basisrelation",
        "baseRelationAttributes": "Attribute der Basisrelation",
        "baseRelationDependencies": "Abhängigkeiten der Basisrelation",
        "subtype": "Unteraufgabe",
        "keysDeterminationPenaltyPerMissingKey": "Punktabzug pro fehlendem Schlüssel",
        "keysDeterminationPenaltyPerIncorrectKey": "Punktabzug pro falschem Schlüssel",
        "attributeClosureBaseAttributes": "Basisattribute",
        "attributeClosurePenaltyPerMissingAttribute": "Punktabzug pro fehlendem Attribut",
        "attributeClosurePenaltyPerIncorrectAttribute": "Punktabzug pro falschem Attribut",
        "minimalCoverPenaltyPerNonCanonicalDependency": "Punktabzug pro nicht-kanonischer Abhängigkeit",
        "minimalCoverPenaltyPerTrivialDependency": "Punktabzug pro trivialer Abhängigkeit",
        "minimalCoverPenaltyPerExtraneousAttribute": "Punktabzug pro überflüssigem Attribut",
        "minimalCoverPenaltyPerRedundantDependency": "Punktabzug pro redundanter Abhängigkeit",
        "minimalCoverPenaltyPerMissingDependencyVsSolution": "Punktabzug pro fehlender Abhängigkeit",
        "minimalCoverPenaltyPerIncorrectDependencyVsSolution": "Punktabzug pro falscher Abhängigkeit",
        "normalFormDeterminationPenaltyForIncorrectOverallNormalform": "Punktabzug bei falscher Gesamt-Normalform",
        "normalFormDeterminationPenaltyPerIncorrectDependencyNormalform": "Punktabzug mit falscher verletzter Normalform bei Abhängigkeit",
        "normalizationTargetLevel": "Ziel-Normalform",
        "normalizationMaxLostDependencies": "The maximum number of functional dependencies that is permitted to be lost in the decomposition process before points are deducted in a normalization task",
        "normalizationPenaltyPerLostAttribute": "Punktabzug pro verlorenem Attribut",
        "normalizationPenaltyForLossyDecomposition": "Punktabzug bei verlustbehafteter Zerlegung",
        "normalizationPenaltyPerNonCanonicalDependency": "Punktabzug pro nicht-kanonischer Abhängigkeit",
        "normalizationPenaltyPerTrivialDependency": "Punktabzug pro trivialer Abhängigkeit",
        "normalizationPenaltyPerExtraneousAttributeInDependency": "Punktabzug pro überflüssigem Attribut in Abhängigkeit",
        "normalizationPenaltyPerRedundantDependency": "Punktabzug pro redundanter Abhängigkeit",
        "normalizationPenaltyPerExcessiveLostDependency": "Punktabzug pro übermäßig verlorene Abhängigkeit",
        "normalizationPenaltyPerMissingNewDependency": "Punktabzug pro fehlender neuer Abhängigkeit",
        "normalizationPenaltyPerIncorrectNewDependency": "Punktabzug pro falscher neuer Abhängigkeit",
        "normalizationPenaltyPerMissingKey": "Punktabzug pro fehlendem Schlüssel",
        "normalizationPenaltyPerIncorrectKey": "Punktabzug pro falschem Schlüssel",
        "normalizationPenaltyPerIncorrectNFRelation": "Punktabzug pro falscher Normalform-Relation"

      },
      "descriptions": {
        "penalty": "Ein Punkteabzug von -1 bedeutet, dass die Abgabe mit 0 Punkten bewertet wird."
      },
      "subtype": {
        "keysDetermination": "Schlüsselbestimmung",
        "attributeClosure": "Bildung der Attributhülle",
        "minimalCover": "Minimale Überdeckung",
        "normalFormDetermination": "Normalformen bestimmen",
        "normalization": "Normalisierung"

      }
    },
    "uml": {
      "title": "UML",
      "fields": {
        "umlBlock": "Block {{id}}",
        "umlSolution": "Lösung",
        "umlAddBlock": "Block hinzufügen",
        "umlAddAlternative": "Alternative hinzufügen",
        "fullComparison": "Vollständiger Vergleich?",
        "classPoints": "Punkte pro richtiger Klasse",
        "associationPoints": "Punkte pro richtiger Assoziation",
        "associationClassPoints": "Punkte pro richtiger Zuordnung einer Assoziationsklasse",
        "constraintPoints": "Punkte pro richtiger Constraint"


      }
    }
  }
}

