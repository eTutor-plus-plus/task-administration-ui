{
  "taskTypes": {
    "none": {
      "title": "Kein Typ"
    },
    "binary-search": {
      "title": "Binärsuche",
      "fields": {
        "solution": "Gesuchte Zahl"
      }
    },
    "xquery": {
      "title": "XQuery",
      "fields": {
        "solution": "Lösung",
        "sorting": "Sortierung (XPath)",
        "missingNodePenalty": "Fehlender Knoten: Punkteabzug",
        "missingNodeStrategy": "Fehlender Knoten: Strategie",
        "superfluousNodePenalty": "Überflüssiger Knoten: Punkteabzug",
        "superfluousNodeStrategy": "Überflüssiger Knoten: Strategie",
        "displacedNodePenalty": "Fehlplatzierter Knoten: Punkteabzug",
        "displacedNodeStrategy": "Fehlplatzierter Knoten: Strategie",
        "missingAttributePenalty": "Fehlendes Attribut: Punkteabzug",
        "missingAttributeStrategy": "Fehlendes Attribut: Strategie",
        "superfluousAttributePenalty": "Überflüssiges Attribut: Punkteabzug",
        "superfluousAttributeStrategy": "Überflüssiges Attribut: Strategie",
        "incorrectTextPenalty": "Falscher Text: Punkteabzug",
        "incorrectTextStrategy": "Falscher Text: Strategie",
        "incorrectAttributeValuePenalty": "Falscher Attributwert: Punkteabzug",
        "incorrectAttributeValueStrategy": "Falscher Attributwert: Strategie"
      },
      "descriptions": {
        "sorting": "Geben Sie hier den XPath-Ausdruck an, der die Sortierung der Ergebnisse überprüft, z. B. '//person'. Ein Eintrag pro Zeile."
      },
      "strategy": {
        "KO": "K.O.-Kriterium",
        "GROUP": "Einmal pro Gruppe",
        "EACH": "Einmal pro Element"
      }
    },
    "datalog": {
      "title": "Datalog",
      "fields": {
        "solution": "Lösung",
        "query": "Abfrage",
        "uncheckedTerms": "Terme",
        "missingPredicatePenalty": "Fehlendes Prädikat: Punkteabzug",
        "missingPredicateStrategy": "Fehlendes Prädikat: Strategie",
        "missingFactPenalty": "Fehlender Fakt: Punkteabzug",
        "missingFactStrategy": "Fehlender Fakt: Strategie",
        "superfluousFactPenalty": "Überflüssiger Fakt: Punkteabzug",
        "superfluousFactStrategy": "Überflüssiger Fakt: Strategie"
      },
      "descriptions": {
        "solution": "Hier können die Regeln, welche die Lösung repräsentieren, definiert werden. Hier dürfen keine Query-Deklarationen erfolgen.",
        "query": "Wenn Sie mehrere Queries bei der Beurteilung berücksichtigen wollen, dann trennen Sie diese mittels Semikolon. Z.B. hatSohn(X,Y)?;hatTochter(X,Y)?",
        "uncheckedTerms": "Um bestimmte Terme, welche in den Fakten vorkommen, von der Manipulation auszuschließen, definieren Sie diese hier erneut. Z.B. 'hatKind(peter,_).' ,um den Term 'peter' von der Manipulation auszuschließen, sofern dieser auf Position 1 des Prädikats 'hatKind' vorkommt. Bei der Überprüfung werden Terme manipuliert, um zu verhindern, dass Studierende einfach die Fakten und keine Regeln eingeben."
      },
      "strategy": {
        "KO": "K.O.-Kriterium",
        "GROUP": "Einmal pro Gruppe",
        "EACH": "Einmal pro Element"
      }
    },
    "asp": {
      "title": "Answer Set Programming",
      "fields": {
        "solution": "Lösung",
        "maxN": "Max. Integer"
      },
      "descriptions": {
        "solution": "Hier können die Regeln, welche die Lösung repräsentieren, definiert werden. Hier dürfen keine Query-Deklarationen erfolgen."
      }
    },
    "drools": {
      "title": "Drools",
      "fields": {
        "droolsSolution": "Lösung",
        "droolsClasses": "Klassen",
        "droolsObjects": "Objekte",
        "droolsErrorWeighting": "Fehlergewichtung",
        "droolsValidationClassname": "Validierungsklasse",
        "droolsAddClass": "Klasse hinzufügen",
        "droolsClassesName": "Klassen",
        "droolsIsCEP": "Ist dieser Task ein CEP Task?"
      }
    },

    "sql-ddl": {
      "title": "SQL DDL",
      "fields": {
        "sqlDDL": "SQL DDL",
        "solution": "Lösung",
        "insertStatements": "Insert Statement",
        "tablePoints": "Punkte pro Tabelle",
        "columnPoints": "Punkte pro Spalte",
        "constraintPoints": "Punkte pro Constraint",
        "primaryKeyPoints": "Punkte pro Primary Key",
        "foreignKeyPoints": "Punkte pro Foreign Key"
  }},
    "sql": {
      "title": "SQL",
      "fields": {
        "solution": "Lösung",
        "wrongOrderPenalty": "Falsche Sortierung: Punkteabzug",
        "superfluousColumnsPenalty": "Überflüssige Spalte: Punkteabzug"
      },
      "descriptions": {
        "penalty": "Ein Punkteabzug von -1 bedeutet, dass die Abgabe mit 0 Punkten bewertet wird."
      }
    },
    "relalg": {
      "title": "Relationale Algebra",
      "fields": {
        "solution": "Lösung",
        "sqlSolution": "SQL-Lösung",
        "wrongOrderPenalty": "Falsche Sortierung: Punkteabzug",
        "superfluousColumnsPenalty": "Überflüssige Spalte: Punkteabzug"
      },
      "descriptions": {
        "penalty": "Ein Punkteabzug von -1 bedeutet, dass die Abgabe mit 0 Punkten bewertet wird."
      }
    },
    "fanf": {
      "title": "Funktionale Abhängigkeiten",
      "fields": {
        "baseRelationName": "Name der Basisrelation",
        "baseRelationAttributes": "Attribute der Basisrelation",
        "baseRelationDependencies": "Abhängigkeiten der Basisrelation",
        "subtype": "Unteraufgabe",
        "keysDeterminationPenaltyPerMissingKey": "Punktabzug pro fehlendem Schlüssel",
        "keysDeterminationPenaltyPerIncorrectKey": "Punktabzug pro falschem Schlüssel",
        "attributeClosureBaseAttributes": "Basisattribute",
        "attributeClosurePenaltyPerMissingAttribute": "Punktabzug pro fehlendem Attribut",
        "attributeClosurePenaltyPerIncorrectAttribute": "Punktabzug pro falschem Attribut",
        "minimalCoverPenaltyPerNonCanonicalDependency": "Punktabzug pro nicht-kanonischer Abhängigkeit",
        "minimalCoverPenaltyPerTrivialDependency": "Punktabzug pro trivialer Abhängigkeit",
        "minimalCoverPenaltyPerExtraneousAttribute": "Punktabzug pro überflüssigem Attribut",
        "minimalCoverPenaltyPerRedundantDependency": "Punktabzug pro redundanter Abhängigkeit",
        "minimalCoverPenaltyPerMissingDependencyVsSolution": "Punktabzug pro fehlender Abhängigkeit",
        "minimalCoverPenaltyPerIncorrectDependencyVsSolution": "Punktabzug pro falscher Abhängigkeit",
        "normalFormDeterminationPenaltyForIncorrectOverallNormalform": "Punktabzug bei falscher Gesamt-Normalform",
        "normalFormDeterminationPenaltyPerIncorrectDependencyNormalform": "Punktabzug mit falscher verletzter Normalform bei Abhängigkeit",
        "normalizationTargetLevel": "Ziel-Normalform",
        "normalizationMaxLostDependencies": "The maximum number of functional dependencies that is permitted to be lost in the decomposition process before points are deducted in a normalization task",
        "normalizationPenaltyPerLostAttribute": "Punktabzug pro verlorenem Attribut",
        "normalizationPenaltyForLossyDecomposition": "Punktabzug bei verlustbehafteter Zerlegung",
        "normalizationPenaltyPerNonCanonicalDependency": "Punktabzug pro nicht-kanonischer Abhängigkeit",
        "normalizationPenaltyPerTrivialDependency": "Punktabzug pro trivialer Abhängigkeit",
        "normalizationPenaltyPerExtraneousAttributeInDependency": "Punktabzug pro überflüssigem Attribut in Abhängigkeit",
        "normalizationPenaltyPerRedundantDependency": "Punktabzug pro redundanter Abhängigkeit",
        "normalizationPenaltyPerExcessiveLostDependency": "Punktabzug pro übermäßig verlorene Abhängigkeit",
        "normalizationPenaltyPerMissingNewDependency": "Punktabzug pro fehlender neuer Abhängigkeit",
        "normalizationPenaltyPerIncorrectNewDependency": "Punktabzug pro falscher neuer Abhängigkeit",
        "normalizationPenaltyPerMissingKey": "Punktabzug pro fehlendem Schlüssel",
        "normalizationPenaltyPerIncorrectKey": "Punktabzug pro falschem Schlüssel",
        "normalizationPenaltyPerIncorrectNFRelation": "Punktabzug pro falscher Normalform-Relation"

      },
      "descriptions": {
        "penalty": "Ein Punkteabzug von -1 bedeutet, dass die Abgabe mit 0 Punkten bewertet wird."
      },
      "subtype": {
        "keysDetermination": "Schlüsselbestimmung",
        "attributeClosure": "Bildung der Attributhülle",
        "minimalCover": "Minimale Überdeckung",
        "normalFormDetermination": "Normalformen bestimmen",
        "normalization": "Normalisierung"

      }
    },
    "uml": {
      "title": "UML",
      "fields": {
        "umlBlock": "Block {{id}}",
        "umlSolution": "Lösung",
        "umlAddBlock": "Block hinzufügen",
        "umlAddAlternative": "Alternative hinzufügen",
        "fullComparison": "Vollständiger Vergleich?",
        "classPoints": "Punkte pro richtiger Klasse",
        "associationPoints": "Punkte pro richtiger Assoziation",
        "associationClassPoints": "Punkte pro richtiger Zuordnung einer Assoziationsklasse",
        "constraintPoints": "Punkte pro richtiger Constraint"


      }
    },
    "knn": {
      "title": "K-Nächste-Nachbarn",
      "meta": "Allgemeine Angaben",
      "model": {
        "knn": "KNN-Klassifikation"
      },
      "labels": {
        "feature": "Merkmal"
      },
      "placeholders": {
        "taskName": "Name der Aufgabe",
        "descriptionDe": "Markdown / HTML möglich …",
        "descriptionEn": "Markdown / HTML möglich …"
      },
      "fields": {
        "k": "K-Wert",
        "trainLabels": "Trainingsklassen",
        "trainLabelsAdd": "Klasse hinzufügen",
        "trainLabelsCount": "Klassen",
        "trainLabelsPlaceholder": "z. B. A, B, C …",
        "trainLabelsError": "Bitte gib für jede Klasse ein Label an (mind. 2 Klassen).",
        "trainLabelsErrorMax": "Maximal 7 Klassen erlaubt.",
        "metric": "Distanz-Metrik",
        "metric.euclidean": "Euklidisch",
        "metric.manhattan": "Manhattan",
        "metric.minkowski": "Minkowski",
        "numTrain": "Trainings-punkte je Klasse",
        "numTest": "Test-punkte",
        "featureName": "Merkmal‑Name",
        "featureRange": "Merkmal-Bereich",
        "xMin": "X-Achse von",
        "xMax": "X-Achse bis",
        "yMin": "Y-Achse von",
        "yMax": "Y-Achse bis",
        "xLabel": "X-Achsen-Beschriftung",
        "yLabel": "Y-Achsen-Beschriftung",
        "tiebreaker": "Tiebreaker-Verfahren",
        "tiebreaker.sum": "Summe der Distanzen (bei Gleichstand alphabetisch)",
        "tiebreaker.mean": "Durchschnitt der Distanzen (bei Gleichstand alphabetisch)",
        "tiebreaker.nearest": "Nächstgelegener Punkt entscheidet (bei Gleichstand alphabetisch)",
        "editTrainPoints": "Trainingspunkte bearbeiten",
        "editTestPoints": "Testpunkte bearbeiten",
        "preview": "Vorschau",
        "feedbackLevel": "Feedback-Level",
        "feedback.RUN": "Nur Syntax-/Format-Check",
        "feedback.DIAGNOSE": "ein bisschen Feedback",
        "feedback.SUBMIT": "Vollfeedback & Punkte",
        "taskName": "Aufgaben-Name",
        "organization": "Organisationseinheit / LVA",
        "taskGroup": "Aufgaben-Gruppe",
        "descriptionDe": "Beschreibung (Deutsch)",
        "descriptionEn": "Beschreibung (Englisch)",
        "maxPoints": "Maximale Punkte",
        "duplicate": "Duplikate in den folgenden Koordinaten erkannt",
        "previewButtons": {
          "generateTaskPdf": "Generiere Aufgabenstellung",
          "generateSolutionPdf": "Generiere Lösung"
        }
      },
      "errors": {
        "required": "Dieses Feld ist erforderlich",
        "min": "Der Wert muss größer als 0 sein"
      }
    } 
  }
}

